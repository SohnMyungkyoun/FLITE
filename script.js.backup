// 전역 변수
let originalImage = null;
let canvas = null;
let ctx = null;
let originalImageData = null;

// 조정 값들
let adjustments = {
    exposure: 0,
    contrast: 0,
    highlights: 0,
    shadows: 0,
    whites: 0,
    blacks: 0
};

// DOM 요소 초기화
document.addEventListener('DOMContentLoaded', () => {
    canvas = document.getElementById('canvas');
    ctx = canvas.getContext('2d', { willReadFrequently: true });
    
    // 이벤트 리스너 설정
    document.getElementById('uploadBtn').addEventListener('click', () => {
        document.getElementById('imageInput').click();
    });
    
    document.getElementById('imageInput').addEventListener('change', handleImageUpload);
    document.getElementById('resetBtn').addEventListener('click', resetAdjustments);
    document.getElementById('exportBtn').addEventListener('click', exportImage);
    
    // 슬라이더 이벤트 리스너
    const sliders = ['exposure', 'contrast', 'highlights', 'shadows', 'whites', 'blacks'];
    sliders.forEach(slider => {
        const element = document.getElementById(slider);
        element.addEventListener('input', (e) => {
            adjustments[slider] = parseInt(e.target.value);
            document.getElementById(`${slider}Value`).textContent = e.target.value;
            applyAdjustments();
        });
    });
});

// 이미지 업로드 처리
function handleImageUpload(e) {
    const file = e.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = (event) => {
        const img = new Image();
        img.onload = () => {
            originalImage = img;
            initializeCanvas();
            document.getElementById('placeholder').style.display = 'none';
            canvas.style.display = 'block';
            document.getElementById('exportBtn').disabled = false;
            resetAdjustments();
        };
        img.src = event.target.result;
    };
    reader.readAsDataURL(file);
}

// 캔버스 초기화
function initializeCanvas() {
    const maxWidth = 1000;
    const maxHeight = 700;
    
    let width = originalImage.width;
    let height = originalImage.height;
    
    // 비율 유지하면서 크기 조정
    if (width > maxWidth || height > maxHeight) {
        const ratio = Math.min(maxWidth / width, maxHeight / height);
        width *= ratio;
        height *= ratio;
    }
    
    canvas.width = width;
    canvas.height = height;
    
    ctx.drawImage(originalImage, 0, 0, width, height);
    originalImageData = ctx.getImageData(0, 0, width, height);
}

// 조정 적용
function applyAdjustments() {
    if (!originalImageData) return;
    
    // 원본 이미지 데이터 복사
    const imageData = ctx.createImageData(originalImageData);
    const data = imageData.data;
    const originalData = originalImageData.data;
    
    // 각 픽셀 처리
    for (let i = 0; i < data.length; i += 4) {
        let r = originalData[i];
        let g = originalData[i + 1];
        let b = originalData[i + 2];
        
        // 밝기 계산 (휘도)
        const luminance = 0.299 * r + 0.587 * g + 0.114 * b;
        
        // 1. 노출 (Exposure) - 전체적인 밝기 조정
        const exposureFactor = 1 + (adjustments.exposure / 100);
        r *= exposureFactor;
        g *= exposureFactor;
        b *= exposureFactor;
        
        // 2. 대비 (Contrast)
        const contrastFactor = (259 * (adjustments.contrast + 255)) / (255 * (259 - adjustments.contrast));
        r = contrastFactor * (r - 128) + 128;
        g = contrastFactor * (g - 128) + 128;
        b = contrastFactor * (b - 128) + 128;
        
        // 3. 밝은 영역 (Highlights) - 밝은 부분만 조정
        if (luminance > 128) {
            const highlightWeight = (luminance - 128) / 127;
            const highlightAdjust = (adjustments.highlights / 100) * highlightWeight * -50;
            r += highlightAdjust;
            g += highlightAdjust;
            b += highlightAdjust;
        }
        
        // 4. 어두운 영역 (Shadows) - 어두운 부분만 조정
        if (luminance < 128) {
            const shadowWeight = (128 - luminance) / 128;
            const shadowAdjust = (adjustments.shadows / 100) * shadowWeight * 50;
            r += shadowAdjust;
            g += shadowAdjust;
            b += shadowAdjust;
        }
        
        // 5. 흰색 계열 (Whites) - 가장 밝은 부분 조정
        if (luminance > 200) {
            const whiteWeight = (luminance - 200) / 55;
            const whiteAdjust = (adjustments.whites / 100) * whiteWeight * 50;
            r += whiteAdjust;
            g += whiteAdjust;
            b += whiteAdjust;
        }
        
        // 6. 검정 계열 (Blacks) - 가장 어두운 부분 조정
        if (luminance < 55) {
            const blackWeight = (55 - luminance) / 55;
            const blackAdjust = (adjustments.blacks / 100) * blackWeight * -50;
            r += blackAdjust;
            g += blackAdjust;
            b += blackAdjust;
        }
        
        // 값 제한 (0-255)
        data[i] = Math.max(0, Math.min(255, r));
        data[i + 1] = Math.max(0, Math.min(255, g));
        data[i + 2] = Math.max(0, Math.min(255, b));
        data[i + 3] = originalData[i + 3]; // 알파 채널 유지
    }
    
    ctx.putImageData(imageData, 0, 0);
}

// 조정 값 초기화
function resetAdjustments() {
    const sliders = ['exposure', 'contrast', 'highlights', 'shadows', 'whites', 'blacks'];
    
    sliders.forEach(slider => {
        adjustments[slider] = 0;
        document.getElementById(slider).value = 0;
        document.getElementById(`${slider}Value`).textContent = '0';
    });
    
    if (originalImageData) {
        ctx.putImageData(originalImageData, 0, 0);
    }
}

// 이미지 내보내기
function exportImage() {
    if (!canvas) return;
    
    // 현재 날짜와 시간으로 파일명 생성
    const now = new Date();
    const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, -5);
    const filename = `edited-photo-${timestamp}.png`;
    
    // Canvas를 Blob으로 변환
    canvas.toBlob((blob) => {
        // 다운로드 링크 생성
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.download = filename;
        link.href = url;
        link.click();
        
        // 메모리 정리
        URL.revokeObjectURL(url);
        
        // 사용자 피드백
        showNotification('✅ 이미지가 성공적으로 내보내졌습니다!');
    }, 'image/png');
}

// 알림 표시
function showNotification(message) {
    const notification = document.createElement('div');
    notification.textContent = message;
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 15px 25px;
        border-radius: 10px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        z-index: 1000;
        animation: slideIn 0.3s ease-out;
        font-weight: 600;
    `;
    
    document.body.appendChild(notification);
    
    setTimeout(() => {
        notification.style.animation = 'slideOut 0.3s ease-out';
        setTimeout(() => notification.remove(), 300);
    }, 3000);
}

// CSS 애니메이션 추가
const style = document.createElement('style');
style.textContent = `
    @keyframes slideIn {
        from {
            transform: translateX(400px);
            opacity: 0;
        }
        to {
            transform: translateX(0);
            opacity: 1;
        }
    }
    
    @keyframes slideOut {
        from {
            transform: translateX(0);
            opacity: 1;
        }
        to {
            transform: translateX(400px);
            opacity: 0;
        }
    }
`;
document.head.appendChild(style);
